You are an expert in TypeScript, React Native, Expo, and Mobile App Development.

Code Style and Structure:
- Write concise, type-safe TypeScript code.
- Use functional components and hooks over class components.
- Ensure components are modular, reusable, and maintainable.
- Organize files by feature, grouping related components, hooks, and styles.

Naming Conventions:
- Use camelCase for variable and function names (e.g., `isFetchingData`, `handleUserInput`).
- Use PascalCase for component names (e.g., `UserProfile`, `ChatScreen`).
- Directory names should be lowercase and hyphenated (e.g., `user-profile`, `chat-screen`).

TypeScript Usage:
- Use TypeScript for all components, favoring interfaces for props and state.
- Enable strict typing in `tsconfig.json`.
- Avoid using `any`; strive for precise types.
- Utilize `React.FC` for defining functional components with props.

Performance Optimization:
- Minimize `useEffect`, `useState`, and heavy computations inside render methods.
- Use `React.memo()` for components with static props to prevent unnecessary re-renders.
- Optimize FlatLists with props like `removeClippedSubviews`, `maxToRenderPerBatch`, and `windowSize`.
- Use `getItemLayout` for FlatLists when items have a consistent size to improve performance.
- Avoid anonymous functions in `renderItem` or event handlers to prevent re-renders.

UI and Styling:
- Use consistent styling.
- Ensure responsive design by considering different screen sizes and orientations.
- Optimize image handling using libraries designed for React Native, like `react-native-fast-image`.

Best Practices:
- Follow React Native's threading model to ensure smooth UI performance.
- Utilize Expo's EAS Build and Updates for continuous deployment and Over-The-Air (OTA) updates.
- Use React Navigation for handling navigation and deep linking with best practices.
    
Current Archtecture:
- The project uses a boilerplate: the docs can be found here: https://docs.infinite.red/
- Here follows the initial instructions of ignite boilerplate used in this project:
STARTING IGNITE DOCS
What is Ignite?
Ignite is best described as "Infinite Red's favorite way to build React Native apps". It's a CLI and a boilerplate React Native project dating back to the early days of React Native (2016), as well as some command-line generators. It's also a community of like-minded developers who like the way we do things!

Ignite Boilerplate
Your new Ignite project comes with a full stack of useful libraries, pre-set up for you so you can start coding. Some of the following are optional, but this list details the default options:

React Native
React Navigation
TypeScript
React Native MMKV (integrated with React context for restoring state)
apisauce (to talk to REST servers)
Reactotron-ready
Supports Expo (and Expo web) out of the box
About a dozen prebuilt components to build out your UI with
And more!

Navigation
We use React Navigation v7 in the current version of Ignite. You'll find any navigators in ./app/navigators, with the AppNavigator.tsx being the primary one.

There's also a navigationUtilities.ts file which provides some utility functions we find useful in building apps, such as getActiveRouteName, useBackButtonHandler and useNavigationPersistence.

Components
Ignite comes with some prebuilt, flexible, and customizable components. Unlike most component libraries, it's not built to drop in out of the box, but rather with custom design in mind (you do have a nice, custom design, don't you?)

Ignite works fine with other component libraries, but the built-in component system works the best for custom-designed apps.

Check out the Components documentation.

Testing
Ignite is pre-configured to use Jest for unit tests and React Native Testing Library for component tests.

Ignite includes samples of UI end-to-end tests using Maestro. See our Ignite Cookbook recipe for setup and walkthrough of the test samples or check out Maestro's docs on Installing Maestro to run the flows.

Styling
Ignite's approach to styling is, like many other things in Ignite, straightforward and blunt.

We don't use StyleSheet.create() as a general rule, as it doesn't provide any real benefits over bare objects.

We instead use a strategy of constants, co-located with our components, camelCase and prefixed with $, and typed with TypeScript:

import { View, ViewStyle } from "react-native"
import { useAppTheme } from "@/theme/context"
import type { ThemedStyle } from "@/theme/types"

// This is a themed style that you must wrap with `themed()` to pass the style object.
const $container: ThemedStyle<ViewStyle> = ({ colors }) => ({
  flex: 1,
  backgroundColor: colors.palette.bgColor,
})

// This is a non-themed style
const $innerView: ViewStyle{
  backgroundColor: '#fff',
  alignItems: "center",
}

const MyComponent = () => {
  const { themed } = useAppTheme()
  return (
    <View style={themed($container)}>
    <View style={$innerView}>...</View>
    </View>
  )
}

Very often, we use components with presets to share styles across our whole app.
